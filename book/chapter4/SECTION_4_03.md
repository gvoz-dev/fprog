# §4.3. Управляющие конструкции

[К началу главы](CHAPTER_4.md)

## Условное выражение if

Выражение **if** в Scala работает почти так же, как во многих других языках.
Оно проверяет условие (предикат), а затем выполняет одну из двух ветвей кода в зависимости от истинности/ложности этого условия:

```scala
if (number < 0)
  -number
else
  number
```

В данном примере вычисляется абсолютное значение (модуль) числа:
- *если* число отрицательное, то возвращается число с противоположным знаком (унарный минус),
- *иначе* возвращается само число.

В отличие от многих других языков программирования в Scala **if** (как и многие другие выражения) возвращает значение. Таким образом, мы можем присвоить значение этого выражения переменной:

```scala
val absNumber = if (number < 0) -number else number
```

Типом данного выражения является *Int*, потому что обе ветви имеют этот тип.

> Общее правило: типом выражения **if** является ближайший общий супертип для обеих ветвей.

## Блок кода {}

Если, например, в какой-либо ветви условного выражения требуется выполнить несколько действий, то все эти действия необходимо сгруппировать в блоке кода **{}**:

```scala
if (number < 0) {
  println("Число отрицательное - меняем знак")
  -number
} else {
  println("Число положительное - ничего не меняем")
  number
}
```

В Scala блок **{}** содержит последовательность выражений и сам считается выражением, результатом которого является значение последнего выражения.

> Во многих других языках программирования (C++, Java и др.) блок кода не является выражением, не имеет типа и не возвращает значения.

## Цикл while

Циклы **while** в Scala ведут себя точно так же, как и в других языках. В них имеются условие (предикат) и тело, которое будет выполняться до тех пор, пока предикат имеет истинное значение:

```scala
var n = 0
while (n <= 10) {
  println(pow(2, n))
  n += 1
}
```

В данном примере печатаются степени числа 2, начиная со степени 0 и до тех пор, пока степень меньше или равна 10.

## Цикл do-while

Цикл **do-while** работает так же, как и цикл **while**, но условие в нём проверяется после тела цикла, а не до него:

```scala
var line = ""
do {
  line = readLine
  println("Прочитано: " + line)
} while (line != "")
```

В данном примере печатаются строки, введённые пользователем, до тех пор, пока не будет введена пустая строка.

> Тело цикла **do-while** всегда выполнится по крайней мере один раз.

> Конструкции **while** и **do-while** являются чисто императивными конструкциями, которые зачастую не включают в функциональные языки. Типом результата этих конструкций является *Unit*.

## Выражение for

Выражение **for** предназначено для итераций.

В самом простом случае **for** можно использовать для перебора элементов коллекции:

```scala
val nums = List(1, 2, 3)
for (i <- nums) println(i)
```

> Код *i <- nums* называется генератором. Циклы **for** могут иметь несколько генераторов. Их следует разделять точкой с запятой.

В выражении **for** можно воспользоваться блоком кода, если необходимо выполнить несколько действий:

```scala
val nums = List(1, 2, 3)
for (i <- nums) {
  val square = i * i
  println(s"i = $i, i^2 = $square")
}
```

Можно создавать объекты *Range*, используя синтаксис вида *1 to 10*, и выполнять их обход с помощью **for**:

```scala
for (i <- 1 to 10) println(i * i)
```

> Если не нужно включать верхнюю границу диапазона в перечисляемые значения, то вместо *to* следует использовать *until*.

Циклы **for** также могут содержать выражения **if**, известные как ограничители (*guards*):

```scala
for (i <- 1 to 10
     if i % 2 == 0)
  println(i)
```

В данном примере числа от 1 до 10 фильтруются по условию их чётности.

Когда тело цикла **for** начинается с **yield**, цикл будет генерировать коллекцию, добавляя в неё по одному элементу на каждой итерации:

```scala
val nums = List(1, 2, 3, 4, 5)
for (i <- nums) yield i * i
```

> Такие циклы называют **for**-генераторами.

Генерируемые коллекции по типу совместимы с первым генератором.

---
[Далее](SECTION_4_04.md)
