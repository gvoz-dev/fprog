# §4.4. Функции и замыкания

[К началу главы](CHAPTER_4.md)

## Функции

Функции в Scala определяются с помощью ключевого слова **def**:

```scala
def max(a: Int, b: Int): Int = {
  if (a > b) a
  else b
}
```

После ключевого слова **def** следуют:
- имя - *max*,
- список параметров в круглых скобках - *(a: Int, b: Int)*
- результирующий тип после двоеточия (:) - *Int*
- тело функции после знака равно (=).

> Совокупность имени и списка параметров часто называется сигнатурой функции.

> Для каждого параметра необходимо явно определить тип, т.к. он не может быть выведен автоматически.

> _Если функция не является рекурсивной_, определять тип результата не обязательно, т.к. он может быть выведен автоматически. Но всё же есть смысл всегда указывать его явно, чтобы сделать код более понятным.

> Результатом функции является значение последнего выражения.

> Блок кода **{}** можно опустить, если тело имеет только одно выражение.

В сокращённом виде функция *max* может выглядеть так:

```scala
def max(a: Int, b: Int) = if (a > b) a else b
```

Для вызова функции необходимо указать её имя и список аргументов в круглых скобках:

```scala
max(-100, 1) // 1
```

## Аргументы по умолчанию

Scala предоставляет возможность задавать значения параметров по умолчанию, чтобы при вызове функций иметь возможность лишний раз не указывать некоторые аргументы:

```scala
def log(message: String, level: String = "INFO"): Unit = println(s"$level: $message")

log("Программа запущена") // INFO: Программа запущена
log("Неверный ввод", "ERROR") // ERROR: Неверный ввод
```

В данном примере у параметра *level* есть значение по умолчанию *"INFO"*, которое указывается после знака равно (=).
В первом вызове значение аргумента *level* не указано, поэтому используется значение по умолчанию.
Во втором вызове значением аргумента *level* указан - строка *"ERROR"* будет использоваться вместо значения по умолчанию.

> Если при вызове пропущен хотя бы один аргумент, то все остальные аргументы должны вызываться с указанием конкретного имени параметра.

## Процедуры

Если тело функции заключено в фигурные скобки без предшествующего знака равно (=), то результирующим типом функции будет *Unit*. Такие функции называются процедурами:

```scala
def hello() {
  println("Как Вас зовут?")
  val name = readLine
  println(s"Привет, $name!")
}
```

Процедуры не возвращают значений и вызываются исключительно ради побочных эффектов.

## Функции первого класса

В Scala функции являются объектами. Их можно передавать в качестве аргументов в другие функции, возвращать из функций, присваивать переменным.

### Анонимные функции

Если функцию требуется передать в качестве аргумента, то необязательно давать ей имя. Можно создать и передать анонимную функцию (лямбда-функцию):

```scala
val numbers = 1 to 10
numbers.map((i: Int) => i * 3)
```

В данном примере в метод *map* передаётся выражение (i: Int) => i * 3, которое является анонимной функцией.
В её определении перед стрелкой (=>) находится список параметров, а после - тело функции.

Эту функцию можно написать в сокращённой форме, опустив определение типа параметра, т.к. он может быть выведен автоматически:

```scala
numbers.map((i) => i * 3)
```

Если параметр один, то можно опустить скобки у списка параметров:

```scala
numbers.map(i => i * 3)
```

И в конце концов, если параметр появляется в теле функции только один раз, то можно не указывать список параметров и стрелку (=>),
а вместо имени переменной использовать символ подчёркивания (_):

```scala
numbers.map(_ * 3)
```

> Анонимную функцию или лямбда-функцию в Scala также называют функциональным литералом.

### Функциональные переменные

Анонимная функция может быть присвоена переменной для создания функциональной переменной:

```scala
val triple = (i: Int) => i * 3
numbers.map(triple)
```

Мы можем указать тип этой переменной (функциональный тип, стрелочный тип):

```scala
val triple: Int => Int = (i: Int) => i * 3
numbers.map(triple)
```

Описание типа в данном примере означает, что функция принимает один параметр типа *Int* и возвращает результат типа *Int*.

### Замыкания

Замыкание - это захват в теле функции свободной переменной:

```scala
var step = 1
val inc = (x: Int) => x + step
```

В данном примере *step* является свободной переменной, которая определена вне функционального литерала.

> В отличие от некоторых других языков значение свободной переменной может быть изменено в ходе выполнения.

---
Далее
