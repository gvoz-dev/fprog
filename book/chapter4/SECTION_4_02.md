# §4.2. Основные типы и операции

[К началу главы](CHAPTER_4.md)

## Определение переменных

Для определения переменных в языке Scala используются следующие ключевые слова: **val** и **var**:

```scala
val a = 42
var b = 7
```

В данном примере мы объявили переменные *a* и *b* со значениями 42 и 7 соответственно.

Ключевое слово **val** используется для определения неизменяемых переменных (констант). Если мы попытаемся переопределить значение переменной *a*, будет ошибка:

```scala
a = 4 // Reassignment to val
```

Если мы хотим иметь возможность изменять значение переменной, следует использовать ключевое слово **var**. Например, значение переменной *b* мы можем изменять беспрепятственно:

```scala
b = 5
```

В данных примерах мы не объявляли явно типы переменных *a* и *b* - они выводились автоматически из типа инициализирующего выражения.
Однако при необходимости тип можно объявить явно:

```scala
val c: Int = 100
```

В данном примере мы определили константу *c* типа *Int*, которая имеет значение 100.

> Тип указывается после имени переменной и двоеточия.

## Иерархия типов в Scala

Супертипом всех типов в Scala является *Any*. Он определяет универсальные методы, такие как *equals*, *hashCode*, *toString*.

> *Any* также называют верхним типом.

*AnyVal* представляет типы значений. Существует несколько предопределённых типов значений: *Double*, *Float*, *Long*, *Int*, *Short*, *Byte*, *Char*, *Boolean* и *Unit*.

*Unit* - это тип значения, который не несёт никакой значимой информации. Существует только один экземпляр типа *Unit* - *()*.

> Аналогом *Unit* в других языках является тип *void*.

*AnyRef* представляет ссылочные типы. Примерами *AnyRef* являются *String*, *Array*, *List* и т.д., а также любой пользовательский тип.

*Null* - это подтип всех ссылочных типов. Он имеет единственное значение, определяемое ключевым словом **null**.

> **null** означает отсутствие ссылки на какой-то конкретный объект.
> В настоящее время применение **null** считается плохой практикой и его не рекомендуется использовать в коде на Scala.

*Nothing* является подтипом всех типов. Нет значения, которое имело бы тип *Nothing*. Он обычно сигнализирует об исключении, выходе из программы или бесконечном цикле.

> *Nothing* также называют нижним типом.

> В официальной [документации](https://docs.scala-lang.net/tour/unified-types.html) есть схема иерархии типов.

## Типы значений

| Тип данных | Описание                     | Диапазон значений                              |
| ---------- | ---------------------------- | ---------------------------------------------- |
| Byte       | 8-битное целое               | от -128 до 127                                 |
| Short      | 16-битное целое              | от -32768 до 32767                             |
| Int        | 32-битное целое              | от -2147483648 до 2147483647                   |
| Long       | 64-битное целое              | от -9223372036854775808 до 9223372036854775807 |
| Float      | 32-битное с плавающей точкой | от 1.4E-45 до 3.4028235E38                     |
| Double     | 64-битное с плавающей точкой | от 4.9E-324 до 1.7976931348623157E308          |
| Boolean    | логическое значение          | false и true                                   |
| Char       | 16-битный символ Unicode     | от '\u0000' до '\uFFFF'                        |

### Числа

Ниже показан пример объявления переменных числовых типов:

```scala
val b: Byte = 100
val s: Short = 1000
val i: Int = 100500
val l: Long = 100500L
val f: Float = 1.0F
val d: Double = 1.0
```

Для целых чисел можно использовать шестнадцатеричную форму записи:

```scala
val hex: Int = 0xFFFF1000
```

Для чисел с плавающей точкой можно использовать экспоненциальную форму записи:

```scala
val e: Double = 123e-5
```

> Числовым типом целых чисел по умолчанию является *Int*, а чисел с плавающей точкой - *Double*.

Бинарные арифметические операции сложения (+), вычитания (-), умножения (*), деления (/) и получения остатка от деления (%) записываются в инфиксной форме:

```scala
2.14 + 1  // res0: Double = 3.14
4L - 2L   // res1: Long = 2
2 * 2     // res2: Int = 4
10 / 3    // res3: Int = 3
10 % 3    // res4: Int = 1
10.0 / 3  // res5: Double = 3.3333333333333335
```

Как было указано выше, числовые типы расширяют *AnyVal*, и все они являются полноценными объектами, а все арифметические операции на самом деле являются методами:

```scala
5.+(1)    // res6: Int = 6
42./(6)   // res7: Int = 7
```

Унарные операции (-) и (+) записываются в префиксной форме или с помощью точечной записи вызовом методов *unary_-* и *unary_+*:

```scala
-5        // res8: Int = -5
5.unary_- // res9: Int = -5
```

У чисел есть и другие полезные методы, например, методы преобразования типов:

```scala
120.toString  // "120"
7.toDouble    // 7.0
99.9.toInt    // 99
```

Числовые типы можно сравнивать с помощью операций отношений "больше" (>), "меньше" (<), "больше или равно" (>=), "меньше или равно" (<=), "равно" (==) и "не равно" (!=):

```scala
4 > 3
3 < 4
4 >= 4
5 <= 7
5 == 5
5 != 4
```

Все эти операции (методы) в качестве результата выдают значение логического типа (булево значение).

### Логический тип

Логический тип Boolean имеет два значения *false* (ложь) и *true* (истина). Операции "логическое И" (&& и &), "логическое ИЛИ" (|| и |) и "исключающее ИЛИ" (^) записываются в инфиксной форме, а "логическое НЕ" (!) - в префиксной:

```scala
true && true  // true
false || true // true
!false        // true
```

Ниже представлена таблица истинности для логических операций:

| x     | y     | &     | \|    | ^     |
| ----- | ----- | ----- | ----- | ----- |
| true  | true  | true  | true  | false |
| true  | false | false | true  | true  |
| false | true  | false | true  | true  |
| false | false | false | false | false |

### Символьный тип

Символы записываются в одинарных кавычках или же с помощью кода из таблицы символов Unicode:

```scala
val c: Char = 'λ'
val ch: Char = '\u0053' // S
```

Символьные литералы могут быть представлены специальными управляющими последовательностями (escape sequences):

| Литерал | Предназначение          |
| ------- | ----------------------- |
| \n      | Перевод строки          |
| \b      | Возврат на одну позицию |
| \t      | Табуляция               |
| \r      | Возврат каретки         |
| \\"     | Двойная кавычка         |
| \\'     | Одинарная кавычка       |
| \\\     | Обратный слэш           |

## Строки

Строковый литерал состоит из символов, заключённых в двойные кавычки:

```scala
"Это строка"
```

В Scala включён механизм для интерполяции строк, позволяющий вставлять выражения в строковые литералы:

```scala
val name = "Roman"
println(s"2 + 2 = ${2 + 2}") // 2 + 2 = 4
println(s"Hello, $name") // Hello, Roman
```

Выражение s"Hello, $name" - обрабатываемый строковый литерал. Перед открывающей кавычкой стоит буква s, которая указывает на необходимость использования *интерполятора строк s*. Он вычисляет встроенные выражения и заменяет их результатами. После знака $ в обрабатываемом строковом литерале можно указать любое выражение, если заключить его в фигурные скобки {}. Если в выражении находится только имя переменной, то его можно указать без скобок.

> Статья про интерполяцию строк и интерполяторы в [документации](https://docs.scala-lang.net/ru/scala3/book/string-interpolation.html).

В Scala есть возможность создавать неформатированные строки. Неформатированные строки начинаются и заканчиваются тремя идущими подряд двойными кавычками ("""):

```scala
"""
Это пример неформатированной строки.
Внутри неё могут содержаться любые символы.
Например, управляющий символ перевода строки - \n.
Или кавычки - " " (кроме трёх кавычек подряд).
"""
```

Ниже представлено несколько полезных методов для работы со строками:

```scala
val name = " Roman Gvozdev "
val tName = name.trim // "Roman Gvozdev"
tName.split(" ") // Array("Roman", "Gvozdev")
tName.charAt(0) // 'R'
tName(0) // 'R'
tName.contains("Rom") // true
tName.substring(0, 5) // "Roman"
tName.take(5) // "Roman"
tName.drop(6) // "Gvozdev"
```

## BigInt и BigDecimal

Числовые типы, представленные ранее, имеют ограничения по диапазону значений и точности.
Для точной (длинной) арифметики можно использовать типы BigInt (целые) и BigDecimal (вещественные числа):

```scala
val bi: BigInt = BigInt(Long.MaxValue) * 2 // нет переполнения
val bd: BigDecimal = BigDecimal(Double.MaxValue) * 2 // нет переполнения
```

## Приоритет операций

| Операция         | Нотация     | Ассоциативность |
| ---------------- | ----------- | --------------- |
| () []            | Постфиксная | Левая           |
| ! ~              | Префиксная  | Правая          |
| * / %            | Инфиксная   | Левая           |
| + -              | Инфиксная   | Левая           |
| >> >>> <<        | Инфиксная   | Левая           |
| < <= > >=        | Инфиксная   | Левая           |
| == !=            | Инфиксная   | Левая           |
| &                | Инфиксная   | Левая           |
| ^                | Инфиксная   | Левая           |
| \|               | Инфиксная   | Левая           |
| &&               | Инфиксная   | Левая           |
| \|\|             | Инфиксная   | Левая           |
| = *= /= %= += -= | Инфиксная   | Правая          |
| ,                | Инфиксная   | Левая           |

> Чем выше операция в таблице, тем выше приоритет.

---
[Далее](SECTION_4_03.md)
