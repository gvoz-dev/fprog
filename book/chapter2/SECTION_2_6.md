# §2.6. Условные выражения и предикаты

[К началу главы](CHAPTER_2.md)

## Предикаты

Предикатом называют выражение, которое возвращает результат логического типа.  
Мы уже [познакомились](SECTION_2_3.md#booleans) с логическим типом данных в Racket, а теперь давайте разберём несколько примеров предикатов на этом языке.

Элементарными предикатами являются операции отношения чисел:

```scheme
(= 1 1) ; #t
(> 2 1) ; #t
(< 2 3) ; #t
(>= 2 (+ 1 1)) ; #t
(<= 2 2.0) ; #t
```

Предикатом равенства значений любых типов является функция equal?:

```scheme
(equal? "one" "one") ; #t
(equal? "one" "two") ; #f
(equal? 2 (+ 1 1)) ; #t
(equal? 1 1) ; #t
(equal? 1 1.0) ; #f
```

> В Racket существуют и другие предикаты равенства (например, eq? и eqv?), информацию о которых можно найти в [документации](https://docs.racket-lang.org/reference/Equality.html).

Мы уже сталкивались с предикатами проверки типа:

```scheme
(number? 1) ; #t
(boolean? #t) ; #t
(string? "\u03BB") ; #t
(procedure? (lambda (x) (* x x))) ; #t
```

При помощи логических операций (not, and, or, xor) можно конструировать составные предикаты:

```scheme
(let ([str "\u03BB"])
  (and (string? str) (= (string-length str) 1))) ; #t
```

А теперь давайте определим свой предикат, который будет возвращать #t, если число чётное:

```scheme
(define (even? n)
  (= (remainder n 2) 0))

(even? 41) ; #f
(even? 42) ; #t
```

> Думаю, вы уже заметили, что имена предикатов в Racket принято завершать знаком вопроса.

## Простое ветвление: if

Операция ветвления в Racket имеет следующую форму с ключевым словом **if**:

```scheme
(if ‹predicate› ‹then-expr› ‹else-expr›)
```

Первое выражение ‹predicate› выполняется всегда. Если значение этого выражения не #f (не ложь), то выполняется ветвь ‹then-expr›, а иначе выполняется ‹else-expr›.

Пример определения функции, которая возвращает модуль числа:

```scheme
(define (abs x)
  (if (< x 0)
      (- x)
      x))

(abs 0) ; 0
(abs 7) ; 7
(abs -7) ; 7
```

> Если ветвь else не предполагается, используйте выражения с ключевыми словами [**when** или **unless**](https://docs.racket-lang.org/reference/when_unless.html).

## Цепочка условий: cond

Если ветвей больше двух, то следует использовать форму с ключевым словом **cond**:

```scheme
(cond
  [‹predicate1› ‹expr1›*]
  [‹predicate2› ‹expr2›*]
  ; ...
  [else ‹exprN›*])
```

Выполнится та ветвь, предикат которого не равен #f. В конце выражения cond можно использовать ветвь else, которая выполнится в том случае, если ни одна из ветвей не выполнилась ранее.

> else в выражении cond является синонимом #t.

Пример простой диалоговой системы:

```scheme
(define (reply s)
  (cond
    [(string-prefix? s "Здравствуй") "Привет!"]
    [(string-prefix? s "До свидания") "Пока!"]
    [(string-suffix? s "?") "Я не знаю."]
    [else "Что?"]))

(reply "Здравствуйте!") ; "Привет!"
(reply "До свидания. Увидимся в следующую субботу.") ; "Пока!"
(reply "Какой у тебя любимы цвет?") ; "Я не знаю."
(reply "Бла-бла-бла") ; "Что?"
```


## Выражение выбора: case

Если нам нужен выбор ветви путём сопоставления результата выражения с некоторыми значениями, то следует использовать форму с ключевым словом **case**:

```scheme
(case (‹expr›)
  [(‹datum1›+) ‹expr1›+]
  [(‹datum2›+) ‹expr2›+]
  ; ...
  [else ‹exprN›+])
```

Значение выражения ‹expr› сравнивается с заданными значениями ‹datum›. Если значения совпадают, то выполняется соответствующая ветвь:

```scheme
(case (+ 2 2)
  [(0) "zero"]
  [(1) "one"]
  [(2 3 4) "many"]) ; "many"
```

Как и в cond можно использовать ветвь else, которая выполнится, если ни одна из ветвей не выполнилась ранее:

```scheme
(case (+ 2 2)
  [(0) "zero"]
  [(1) "one"]
  [(2) "two"]
  [else "many"]) ; "many"
```

> В других языках программирования подобное выражение часто называется оператором **switch**.  
> else в выражении case является синонимом значения по умолчанию (default).

---
Далее
