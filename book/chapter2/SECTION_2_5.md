# §2.5. Лямбда-функции

[К началу главы](CHAPTER_2.md)

## Создание функций с помощью lambda

Ключевое слово **lambda** предназначено для создания анонимных функций (лямбда-функций), т.е. функций без имени:

```scheme
(lambda (‹arg›*) ‹expr›+)
```

После ключевого слова lambda указывается список аргументов (формальные параметры), которых может быть любое количество, а далее следует тело функции.

Пример определения лямбда-функции:

```scheme
(lambda (x y) (+ x y))
```

Чтобы вызвать лямбда-функцию, необходимо в выражении после её определения указать аргументы (фактические параметры):

```scheme
((lambda (x y) (+ x y)) 100 1) ; 101
```

Если есть необходимость использовать лямбда-функцию несколько раз, можно определить и связать переменную с ней:

```scheme
(define square
  (lambda (x)
    (* x x)))
```

> На самом деле эта запись эквивалентна следующей:
> 
> ```scheme
> (define (square x)
>   (* x x))
> ```
> 
> Уже известный нам способ определения функции с помощью ключевого слова define является сокращённым способом определения функций с именем, т.е. является, в сущности говоря, *синтаксическим сахаром*.

Вызывается она аналогичным способом:

```scheme
(square 5) ; 25
```

## Функции как объекты первого класса

Функции в функциональных языках программирования (и конкретно в Racket) являются объектами первого класса, т.е. они:
- могут являться аргументом другой функции,
- могут быть возвращены из другой функции,
- могут быть присвоены переменной.

Пример присваивания функции переменной мы уже видели в прошлом разделе, поэтому рассмотрим примеры двух других свойств.

Пример передачи функции в качестве аргумента в другую функцию:

```scheme
(define (apply f a b)
  (f a b))

(apply + 41 1) ; 42
```

Пример функции, которая является возвращаемым значением из другой функции:

```scheme
(define (add-suffix sx)
  (lambda (str)
    (string-append str sx)))

(add-suffix "!") ; #<procedure>
((add-suffix "!") "Привет") ; "Привет!"
```

---
Далее
